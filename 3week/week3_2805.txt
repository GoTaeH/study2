1. 문제 해결 기법
    - 높이를 지정하면 땅으로 부터 H미터 위로 이동해 연속해 있는 나무를 모두 자르는 절단기를 사용하여 잘린 나무를 집에 
    가져가려고 한다. 나무의 수 N과 가져가려고 하는 나무의 길이 M을 입력 받아 절단기에 설정할 수 있는 높이의 최댓값을 구하는 문제이다.
    잘려나가는 나무(가져 가는 나무)와 잘려진 나무(절단기 높이 보다 낮은 나무)는 서로 연관되어 있으므로(한쪽이 짧아지면 다른쪽은 길어진다)
    이분탐색을 사용하여 문제를 해결한다.

2. 논리 구현
버퍼리더를 선언한다.
문자열을 토큰화하는 StringTokenizer을 선언한다.

타입이 int인 N을 입력 받은 토큰으로 정의한다.
타입이 int인 M을 입력 받은 토큰으로 정의한다.
int 배열 wood를 크기가 N인 배열로 생성한다. int[] wood = new int[N]

타입이 int인 min을 0으로 초기화한다.
타입이 int인 max를 0으로 초기화한다.
st = new StringTokenizer(br.readLine())

for 반복문을 통해 다음을 반복한다. (int i <- 0~N-1)
    wood[i]에 입력 받은 토큰을 넣는다.

    if(max < wood[i])   // 입력할 때마다 max 변수와 비교하여 wood[i]가 클 때 max 값을 변경해준다.
        max = wood[i]

while문을 사용하여 다음을 반복한다. (min < max) // 이분 탐색
    int middle을 정의한다. (min + max)/2    // 최소 값과 최대 값의 중간
    타입이 long인 나무길이 합산 변수 sum을 0으로 초기화한다.
    for 반복문으로 다음을 반복한다. (int H : wood) // wood의 객체를 차례대로 H에 넣는다
        if(H - middle > 0) // 잘린 길이의 합을 구하는데, 0보다 작은 값은 음수 이므로 포함하지 않는다.
            sum += (H-middle)
    if(sum < M) // 자르는 위치가 높다 즉, max를 낮춰야한다.
        max = middle
    else // 자르는 위치가 낮다 즉, min을 올려야 한다.
        min = middle + 1;
높이의 최댓값을 출력한다. // min -1