1. 문제 해결 기법
    - N X M의 행렬로 표현되는 벽이 있거나(1), 없는(0) 상태의 맵에서 (1, 1)에서 (N, M)으로 이동하는 
    최단경로를 구한다. 이동하는 도중에 벽을 하나는 부수고 이동해도 된다는 조건이 있다. 이런 조건을 포함하여 
    최단경로를 구하는 문제이다. 따라서 dp 점화식을 통해 최단 경로(너비 우선 탐색)를 구현할 수 있다.

2. 논리 구현
버퍼리더 br을 선언한다.
StringTokenizer st를 선언하고 br.readLine()으로 입력받아 토큰으로 나눈다.

타입이 int인 N, M을 차례대로 토큰으로 정의한다.

if(시작 지점과 도착지점이 같다면)
    1을 출력한다.
    exit(0)
int[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1} // 상하좌우
char타입의 2차원 배열 route를 크기 N*M으로 정의한다.    // 맵 배열
int타입의 2차원 배열 distance를 크기 N*M으로 정의한다.      // 거리 길이
boolean타입의 3차원 배열 visited를 2*N*M으로 정의한다.      // 벽을 부쉈는지의 여부 0또는 1, 2가지
큐를 생성한다.

for 반복문으로 다음을 반복한다. (int i <- 0~N-1)
    String s를 선언하고 br.readLine()으로 입력 받는다.
    for 반복문으로 다음을 반복한다. (int j <- 0~M-1)
        route[i][j] = s.charAt(j);  // 맵 배열에 넣는다.

큐의 시작점을 0,0,0으로 설정한다.   // x, y, 벽 부순 여부, offer사용

while(큐가 비어있지 않는 동안)
    int 타입의 1차원 배열 now에 현재 위치를 뽑아서 저장한다. // queue.poll()
    for 반복문으로 다음을 반복한다. (int i <- 0~3)  // 상하좌우 탐색
        int nx = now[0] + dx[i]
        int ny = now [1] + dy[i]
        if(nx < 0 || nx >= N || ny < 0 || ny >= M)
            계속한다.
        if(벽이 있을 때)
            if(벽을 방문하지 않았고, 벽을 부순 적이 없다면)
                방문했다고 처리한다. // true
                distance[nx][ny] = distance[now[0]][now[1]] +1  // 거리를 잰다
                다시 큐에 int[]{nx, ny, 1}을 넣는다. // 1 : 부순 벽
        else // 벽이 아니라면
            if(그 칸을 방문하지 않았다면)
                방문했다고 처리한다. // true
                벽이 있을 때와 마찬가지로 거리를 잰다.
                큐에 int[]{nx, ny, now[2]}를 넣는다.
        if(도착지점에 도착 했다면)
            distance[nx][ny] + 1을 출력한다.    // 거리
            exit(0)
-1을 출력한다.  // 도달하지 못한 경우