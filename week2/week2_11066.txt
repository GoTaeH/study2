1. 문제 해결 기법
    - 다른 파일에 저장한 소설의 각 장(chapter)을 합쳐서 임시파일을 만들고 임시파일과 원래 파일을 합쳐나가는 방식으로 
    하나의 파일을 만드는데 필요한 최소 비용(두 파일 크기의 합)을 구하는 문제이다. dp를 활용하여 비용을 구해서 저장하고(메모이제이션), 
    저장한 비용 중 가장 작은 비용을 출력한다. dp 최적화 기법 중 하나인 Knuth Optimization을 활용하여 최적화한다. 
    // DP[i][j] = Min{ DP[i][k] + DP[k + 1][j] + C[i][j] | k <- i ~ j } 

2. 논리 구현
Scanner를 정의한다.
타입이 int인 T(테스트데이터 수)를 정의하여 스캐너로 입력받는다.
타입이 int인 2차원 배열 dp를 정의한다.

for 반복문으로 다음을 반복한다. (int m <- 0~T-1)
    int K(장의 수)를 정의하여 스캐너로 입력을 받는다. 
    타입이 int인 배열 sum을 선언하고, K+1임을 정의한다.
    2차원 배열 dp를 int[K+1][K+1]로 정의한다.
    타입이 int인 cost를 선언한다.
    
    for 반복문으로 다음을 반복한다. (int j <- 1~K)
        cost를 스캐너로 입력받는다.
        sum[j]에 sum[j-1]+cost를 더한다. // sum[j] += sum[j-1]+cost
    
    for 반복문으로 다음을 반복한다. (int k <- 1~K-1) // 마지막부분
        for 반복문으로 다음을 반복한다. (int i <- 1~K-k) // 시작부분
            2차원 배열 dp[i][i+k]의 최대값을 구한다. // Integer.MAX_VALUE
            for 반복문으로 다음을 반복한다. (int j <- i~i+k-1) // 중간부분
                dp[i][i+k]배열에 두 값 중 작은 값을 넣는다. // Math.min(dp[i][i+k], dp[i][j] + dp[j+1][i+k])
            dp[i][i+k] 에 sum[i+k] - sum[i-1]을 더한다. // 한 번 반복할 때 비용 합 누적
    dp[1][K]를 출력한다. // 최소 비용