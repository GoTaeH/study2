1. 문제 해결 기법
    - 주어진 수열 A의 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다. 가장 긴 증가하는 부분 수열을 구하기 위해서 
    이분탐색을 사용한다. (이분탐색은 입력된 값이 리스트에 있는 값보다 작거나 같을 경우 적합한 자리를 찾는 경우에서 사용된다.)

2. 논리 구현
버퍼리더 br을 선언한다.
타입이 int인 A을 정의하여 버퍼리더로 입력받는다. 
int 1차원 배열 arr을 크기 A로 정의한다.
List<Integer> list를 정의한다. ArrayList<>()
list의 첫번째 위치에 0을 추가한다. list.add(0)  // 첫번째 입력받은 수를 비교하기 위함, 모든 수 보다 작은 0
문자열을 토큰으로 나누는 StringTokenizer st를 선언한다.

for 반복문으로 다음을 반복한다. (int i <- 0~A-1)
    arr[i]에 토큰을 넣는다.
    if(arr[i] > list.get(list.size() -1))   // 입력받은 값이 리스트 크기 -1보다 큰 경우 (0을 넣었기 때문에 -1을 해주어야 한다.)
        list.add(arr[i])    // 리스트에 값을 추가한다.
    else
        int l (left) = 0    // 리스트의 왼쪽
        int r (right) = list.size() - 1     // 리스트의 오른쪽
        while(왼쪽이 오른쪽보다 작은 동안 반복)
            int mid = (l + r) / 2   // 리스트의 중간은 왼쪽 + 오른쪽 / 2
            if(list.get(mid) >= arr[i])     // 리스트의 중간에 위치한 값이 arr[i]보다 크거나 같다면 (이분탐색)
                r = mid
            else
                l = mid - 1
        list.set(r, arr[i])     // 리스트의 r을 arr[i]로 대체한다.
list.size() - 1을 출력한다.     // 리스트 크기가 가장 긴 증가하는 부분 수열의 길이이다.